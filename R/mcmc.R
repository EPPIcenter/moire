#' Sample from the target distribution using MCMC
#'
#' @export
#'
#' @param data Data to be used in MCMC, as generated by the `load_*_data` functions
#' @param is_missing Boolean matrix indicating whether the observation
#'  should be treated as missing data and ignored. Number of rows equals the
#'  number of loci, number of columns equals the number samples. Alternatively,
#'  the user may pass in FALSE if no data should be considered missing.
#' @param allow_relatedness Bool indicating whether or not to allow relatedness
#'  within host
#' @param thin Positive Integer. How often to sample from mcmc,
#'  1 means do not thin
#' @param burnin Positive Integer. Number of MCMC samples to
#'  discard as burnin
#' @param samples_per_chain Positive Integer. Number of samples to take
#'  after burnin
#' @param verbose Logical indicating if progress is printed
#' @param eps_pos_alpha Positive Numeric. Alpha parameter in
#'  Beta distribution for eps_pos prior
#' @param eps_pos_beta Positive Numeric. Beta parameter in
#'  Beta distribution for eps_pos prior
#' @param eps_neg_alpha Positive Numeric. Alpha parameter in
#'  Beta distribution for eps_neg prior
#' @param eps_neg_beta Positive Numeric. Beta parameter in
#'  Beta distribution for eps_neg prior
#' @param r_alpha Positive Numeric. Alpha parameter in Beta
#' distribution for relatedness prior
#' @param r_beta Positive Numeric. Beta parameter in Beta
#' distribution for relatedness prior
#' @param mean_coi_shape shape parameter for gamma hyperprior on mean COI
#' @param mean_coi_scale scale parameter for gamma hyperprior on mean COI
#' @param max_eps_pos Numeric. Maximum allowed value for eps_pos
#' @param max_eps_neg Numeric. Maximum allowed value for eps_neg
#' @param max_coi Positive Numeric. Maximum allowed complexity of infection
#' @param num_chains Total number of chains to run, possibly simultaneously
#' @param num_cores Total OMP parallel threads to use to run chains.
#'  num_cores * pt_num_threads should not exceed the number of cores available
#'  on your system.
#' @param pt_chains Total number of chains to run with parallel tempering or a
#' vector containing the temperatures that should be used for parallel tempering.
#' @param pt_grad Power to raise parallel tempering chains to. A value of 1
#'  results in evenly distributed temperatures between \[0,1\], below 1 will bias
#'  towards 1 and above 1 will bias towards 0. Only used if pt_chains is a
#'  single value (i.e. not a vector).
#' @param pt_num_threads Total number of OMP parallel threads to be used to
#'  process parallel tempered chains
#'  num_cores * pt_num_threads should not exceed the number of cores available
#'  on your system.
#' @param adapt_temp Logical indicating whether or not to adapt the parallel
#' tempering temperatures. If TRUE, the temperatures will be adapted during the
#' `burnin` period, starting after `pre_adapt_steps` steps. The adaptation will
#' occur every `temp_adapt_steps` steps until burnin is complete. The range of
#' temperatures will remain the same as specified by `pt_chains`.
#' @param pre_adapt_steps Number of steps to take before starting to adapt the
#' parallel tempering temperatures. Only used if `adapt_temp` is TRUE.
#' @param temp_adapt_steps Number of steps to take between temperature
#' adaptation steps. Only used if `adapt_temp` is TRUE.
run_mcmc <-
  function(data,
           is_missing = FALSE,
           allow_relatedness = TRUE,
           thin = 1,
           burnin = 1e4,
           samples_per_chain = 1e3,
           verbose = TRUE,
           eps_pos_alpha = 1,
           eps_pos_beta = 1,
           eps_neg_alpha = 1,
           eps_neg_beta = 1,
           r_alpha = 1,
           r_beta = 1,
           mean_coi_shape = .1,
           mean_coi_scale = 10,
           max_eps_pos = 2,
           max_eps_neg = 2,
           max_coi = 40,
           num_chains = 1,
           num_cores = 1,
           pt_chains = 1,
           pt_grad = 1,
           pt_num_threads = 1,
           adapt_temp = TRUE,
           pre_adapt_steps = 25,
           temp_adapt_steps = 25) {
    start_time <- Sys.time()
    args <- as.list(environment())
    mcmc_args <- as.list(environment())
    mcmc_args$data <- data$data
    mcmc_args$sample_ids <- data$sample_ids
    mcmc_args$loci <- data$loci

    ## if is_missing == FALSE, then generate a default FALSE matrix
    suppressWarnings({
      if (inherits(mcmc_args$is_missing, "logical") && mcmc_args$is_missing == FALSE) {
        num_loci <- length(mcmc_args$loci)
        num_biological_samples <- length(mcmc_args$sample_ids)
        mcmc_args$is_missing <- matrix(
          FALSE,
          nrow = num_loci,
          ncol = num_biological_samples
        )
      }
    })

    total_alleles <- lapply(mcmc_args$data, function(x) {
      return(length(x[[1]]))
    })

    if (any(total_alleles < 2)) {
      stop("Loci with less than 2 alleles present, remove these loci")
    }

    if (max_coi < 1) {
      stop("Max COI must be greater than 1")
    }

    if (length(pt_chains) == 1) {
      mcmc_args$pt_chains <- seq(1, 0, length.out = pt_chains)**pt_grad
    }


    res <- list()
    chains <- list()
    if (num_chains > 1) {
      chains <- parallel::mclapply(
        1:num_chains,
        function(i) {
          mcmc_args$chain_number <- i
          mcmc_args$simple_verbose <- (mcmc_args$num_chains > 1)
          mcmc_args$samples <- round(mcmc_args$samples_per_chain)
          chain <- run_mcmc_rcpp(mcmc_args)
          chain$mean_coi <- chain$lam_coi / (1 - exp(-chain$lam_coi))
          return(chain)
        },
        mc.cores = num_cores
      )
    } else {
      mcmc_args$chain_number <- 1
      mcmc_args$simple_verbose <- FALSE
      mcmc_args$samples <- mcmc_args$samples_per_chain
      chain <- run_mcmc_rcpp(mcmc_args)
      chain$mean_coi <- chain$lam_coi / (1 - exp(-chain$lam_coi))
      chains[[1]] <- chain
    }

    end_time <- Sys.time()

    res$runtime <- end_time - start_time
    res$chains <- chains
    res$args <- args

    res
  }
